# LeetCodeTest
My LeetCode Testing Code
这是一个记录练习leetCode题目的项目。

## Day 1
### 两数之和
求两数之和是相对简单的题目，在一个数组中，求和为目标值的指针，我用了双指针的方法，这应该是效率最慢但是最简单粗暴的方法。
后面应该会逐渐想到更好的办法。
### 反转链表
链表并不陌生，只是时隔了两年，对数据结构已经很生了，想不出处理节点的方式，因为提示要用递归，尝试着用，后来在网上找了递归的例子
才算能解决，初步不算很顺利。递归是一种思路，一种思想吧，很多情况下会用到的，而且能节省空间控制代码设计，这个过程中，我想起了二叉树的遍历
对于遍历，递归应该是常用的方式了，在每一层，加上相对的判断和处理，能达到仿真的效果。

## Day 2
### 存在重复元素
这个题目和两数之和有点相似，用双重循环可以解决，但是我看到了更好的方式，用set判断，想打开了新的思路一样，很兴奋。
### 存在重复元素II
升级版，确实把我难住了，已经不是双重循环可以解决得了，因为LeetCode限制了时间，无疑时间复杂度到了O(n2)。网上看到有人用的是HashMap，这个是很巧妙的
因为HashMap的key不可重复，可以根绝Key去查重复，并把索引值赋值给value，如果不符合就覆盖，让当前节点一直和前一个重复节点比较。
HashMap的containsKey()方法的平均时间复杂度为O(1),要不ArrayList的contains()方法快，因为后者是用遍历。

## Day 3
### 用队列实现栈
起初用list来实现，发现数据类型总是报错，后来发现网上用队列，才发现了有Queue队列，用LinkedList实现，后来测试还是不对，因为Queue是FIFO的，而我要做一个Stack，用两个队列来实现一个栈，因为要做成先进后出，所以要一直有一个空队列来存放不用操作的（top-1）个元素。
### 反转二叉树
使用了递归的方式反转

## Day 4
### 判断一个数是2的幂
一开始想到了右移'>>'，但是右移运算可以，不太好判断，所以想到了按位与运算 '&' 。这里整理一下运算符
* '&' 按位与运算符：同时为1，结果为1，否则为0
* '|' 按位或运算符：一个为1，结果为1
* '^' 异或运算符：两位值不同，结果为1，否则为0
* '~' 取反运算符：将0变1，1变0，就是反着来
* '<<' 左移运算符：二进制位全部左移若干位，左边丢弃，右边补0
* '>>' 右移运算符：各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃
### 用栈实现队列
之前做过用队列实现栈，用到了两个LinkedList，这次用栈实现队列，我也用到了两个Stack，因为队列是LIFO，而栈是FIFO，我是用一个副本Stack，专门转存倒序的元素，在push的过程中，每次都是对一个原Stack操作，而peek和pop的过程中，将原Stack倒序存入副本中，然后对副本进行操作，再将副本存回原Stack。

## Day 5
### 回文链表
用快慢指针法找到链表的中点，反转后半部分链表，从head和slow向后依次比较。这样时间复杂度为O(n)，空间复杂度为O(1)。
### 判断二叉树最近公共父节点
这个一开始没有思路的，一直想用递归，但无从下手，看网上有很多方式，有一个特别好的思路，还是用的递归。

## Day 6
### 删除链表中的节点
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。
一开始比较蒙，因为只给了一个节点，什么也没了，但又感觉这个不难，用后面的节点将当前节点覆盖就可以了。
只是一开始，我用node.next覆盖node，没有起作用。
### 错误的集合
这是个很简单的题目，但是总是没有实现，因为读错了题目，以为数组下标正确状态下应该相同，当不同的时候，可以用到set集合，但是这里用了网上的方法，就是用数组来标识重复的元素，再用数据遍历出错误的元素和他应该正确的元素。

## Day 7
### 二分查找
中断了一段时间, 想系统的学习一下算法, 从二分查找开始!
运行时间: O(logn)
注意: high指针需要指向数组最后一个, 不能设为数组长度, 防止运行中溢出.
